/************************************************
/* assert false stmts at the end are to make sure that
/* the verifier actually gets to those stmts.
************************************************/

field f: Int
method test0(x: Ref)
requires acc(x.f)
ensures acc(x.f)
{
    //:: ExpectedOutput(assert.failed:assertion.false)
    assert x.f > 3
    //:: ExpectedOutput(assert.failed:assertion.false)
    assert x.f > 4
    assert x.f > 3
    //:: ExpectedOutput(assert.failed:assertion.false)
    assert false
}


 method test1(n: Int) {
    //:: ExpectedOutput(assert.failed:assertion.false)
    assert n != 0
    assert n != 0
    //:: ExpectedOutput(assert.failed:assertion.false)
    assert n != 1
    //:: ExpectedOutput(assert.failed:assertion.false)
    assert false
 }

 domain dummy {
    function W(n: Int): Bool
    axiom W_always_true { forall x: Int :: W(x) }
 }

 method test2(n: Int) {
    //:: ExpectedOutput(assert.failed:division.by.zero)
    assert W(n/n) // div by zero?
    assert n != 0

    //:: ExpectedOutput(assert.failed:assertion.false)
    assert false
 }

 method test3(xs: Seq[Int], idx: Int) {
    var z: Int
    //:: ExpectedOutput(assignment.failed:seq.index.negative)
    //:: ExpectedOutput(assignment.failed:seq.index.length)
    z := xs[idx] // index out of bounds?
    assert 0 <= idx && idx < |xs|
    //:: ExpectedOutput(assert.failed:assertion.false)
    assert false
 }

 method testSequenceB(xs: Seq[Int], idx: Int){
    var z: Int
    //:: ExpectedOutput(assert.failed:assertion.false)
    assert idx < |xs|
    //:: ExpectedOutput(assignment.failed:seq.index.negative)
    z := xs[idx]

    //:: ExpectedOutput(assert.failed:assertion.false)
    assert false
 }
 method testSequenceC(xs: Seq[Int], idx: Int){
    var z: Int
    //:: ExpectedOutput(assert.failed:assertion.false)
    assert idx > 0
    //:: ExpectedOutput(assignment.failed:seq.index.length)
    z := xs[idx]

    //:: ExpectedOutput(assert.failed:assertion.false)
    assert false
 }

 method testSequenceD(xs: Seq[Int], idx: Int, u: Int){
    var xs2: Seq[Int]
    //:: ExpectedOutput(assignment.failed:seq.index.length)
    //:: ExpectedOutput(assignment.failed:seq.index.negative)
    xs2 := xs[idx := u]

    //:: ExpectedOutput(assert.failed:assertion.false)
    assert false
 }
 method testSequenceE(xs: Seq[Int], idx: Int, u: Int){
    var xs2: Seq[Int]
    //:: ExpectedOutput(assert.failed:assertion.false)
    assert idx > 0
    //:: ExpectedOutput(assignment.failed:seq.index.length)
    xs2 := xs[idx := u]

    //:: ExpectedOutput(assert.failed:assertion.false)
    assert false
 }
 method testSequenceF(xs: Seq[Int], idx: Int, u: Int){
    var xs2: Seq[Int]
    //:: ExpectedOutput(assert.failed:assertion.false)
    assert idx < |xs|
    //:: ExpectedOutput(assignment.failed:seq.index.negative)
    xs2 := xs[idx := u]

    //:: ExpectedOutput(assert.failed:assertion.false)
    assert false
 }

 function square(n: Int): Int
    requires n <= 0
 { n*n }

 method testFapp(n: Int) {
    //:: ExpectedOutput(application.precondition:assertion.false)
    assert 0 <= square(n) // precond. might not hold
    assert n <= 0

    //:: ExpectedOutput(assert.failed:assertion.false)
    assert false
 }
method testDivByZero(a: Int, b: Int){
    //:: ExpectedOutput(assert.failed:assertion.false)
    assert a == 0

    //:: ExpectedOutput(assert.failed:division.by.zero)
    assert a/b == 0
    assert b != 0

    //:: ExpectedOutput(assert.failed:assertion.false)
    assert false
}

method test5b(a: Int, b: Int){
    //:: ExpectedOutput(assert.failed:assertion.false)
    // :: ExpectedOutput(assert.failed:division.by.zero) TODO:J we would want to get this error as well ideally
    assert a/b == 0
    assert b != 0

    //:: ExpectedOutput(assert.failed:assertion.false)
    assert false
}

method test6(a: Int, b: Int){
    var c: Int

    //:: ExpectedOutput(assignment.failed:division.by.zero)
    c := a % b

    assert b != 0

    //:: ExpectedOutput(assert.failed:assertion.false)
    assert false

}
method testForPermA(y: Ref)
requires acc(y.f)
{
    //:: ExpectedOutput(assert.failed:assertion.false)
    assert forperm x: Ref [x.f] :: x.f > 2
    assert y.f > 2
    //:: ExpectedOutput(assert.failed:assertion.false)
    assert false
}
method testForPermB(y: Ref)
requires acc(y.f)
{
    //:: ExpectedOutput(assert.failed:assertion.false)
    assert forperm x: Ref [x.f] :: x.f != 0
    var z: Int
    z := y.f/y.f
    //:: ExpectedOutput(assert.failed:assertion.false)
    assert false
}

method testAbsLocalVar(b: Bool){
    var b2: Bool
    b2 := b
    //:: ExpectedOutput(assert.failed:assertion.false)
    assert b
    //:: ExpectedOutput(assert.failed:assertion.false)
    assert !b
}
method testPermA(x: Ref, y: Ref)
   requires acc(x.f, 1/2)
{
    //:: ExpectedOutput(assert.failed:assertion.false)
   assert perm(y.f) > none
   assert x == y
    //:: ExpectedOutput(assert.failed:assertion.false)
   assert false
}
method testPermB(x: Ref)
   requires acc(x.f, 1/2)
{
    //:: ExpectedOutput(assert.failed:assertion.false)
   assert perm(x.f) > 2/3
}
method testPermC(x: Ref, p: Perm)
   requires acc(x.f, p)
{
    //:: ExpectedOutput(assert.failed:assertion.false)
   assert perm(x.f) > 1/2
    //:: ExpectedOutput(assert.failed:assertion.false)
    assert false
}
 method testMapA(b: Bool) {
  var m : Map[Int, Int] := Map(2 := 12, 3 := 24, 4 := 36)
  var z: Int
  if(b){
    z := 2
  } else {
    z := 9
  }
  //:: ExpectedOutput(assert.failed:assertion.false)
  assert z in m
  assert z in m
  assert b
  //:: ExpectedOutput(assert.failed:assertion.false)
  assert false
 }
 method testMapB(z: Int) {
  var m : Map[Int, Int] := Map(2 := 12)
  //:: ExpectedOutput(assert.failed:assertion.false)
  assert z in m

  assert z == 2

  //:: ExpectedOutput(assert.failed:assertion.false)
  assert false
 }
method testMultisetA(x: Int) {
  var B: Multiset[Int] := Multiset(1,2,3,3,1)

  //:: ExpectedOutput(assert.failed:assertion.false)
  assert (x in B) == 1

  assert x == 2

  //:: ExpectedOutput(assert.failed:assertion.false)
  assert false
}
method testMultisetB(x: Int) {
  var B: Multiset[Int] := Multiset(1,2,3,3,1)

  //:: ExpectedOutput(assert.failed:assertion.false)
  assert (x in B) == 2

  assert (x == 1) || (x == 3)

  //:: ExpectedOutput(assert.failed:assertion.false)
  assert false
}